// depth first search
func DFS(root: BinaryTreeNode) -> [Int] {
    var stack = Stack<BinaryTreeNode>()
    stack.push(root)
    
    var nodesExplored = [Int]()
    
    while !stack.isEmpty {
        let node = stack.pop()
        nodesExplored.append((node?.val)!)
        
        if node?.right != nil {
            stack.push((node?.right)!)
        }
        
        if node?.left != nil {
            stack.push((node?.left)!)
        }
        
    }
    
    return nodesExplored
}

// breadth first search
func BFS(root: BinaryTreeNode) -> [Int] {
    var queue = Queue<BinaryTreeNode>()
    queue.enqueue(root)
    
    var nodesExplored = [Int]()
    
    while !queue.isEmpty {
        let node = queue.dequeue()
        nodesExplored.append((node?.val)!)
        
        if node?.left != nil {
            queue.enqueue((node?.left)!)
        }
        if node?.right != nil {
            queue.enqueue((node?.right)!)
        }
    }
    
    return nodesExplored
}

// in order traversal
func inOrder(root: BinaryTreeNode?) -> [Int] {
    var nodesExplored = [Int]()
    if root != nil {
        nodesExplored += inOrder(root: root?.left)
        nodesExplored.append((root?.val)!)
        nodesExplored += inOrder(root: root?.right)
    }
    
    return nodesExplored
}

// pre order traversal
func preOrder(root: BinaryTreeNode?) -> [Int] {
    var nodesExplored = [Int]()
    if root != nil {
        nodesExplored.append((root?.val)!)
        nodesExplored += preOrder(root: root?.left)
        nodesExplored += preOrder(root: root?.right)
    }
    
    return nodesExplored
}

// post order traversal
func postOrder(root: BinaryTreeNode?) -> [Int] {
    var nodesExplored = [Int]()
    
    if root != nil {
        nodesExplored += postOrder(root: root?.left)
        nodesExplored += postOrder(root: root?.right)
        nodesExplored.append((root?.val)!)
    }
    
    return nodesExplored
}

// min depth of a BT
func minDepth(root: BinaryTreeNode?) -> Int {
    if root == nil {
        return 0
    }
    
    if root?.left == nil && root?.right == nil {
        return 1
    }
    
    if root?.left == nil {
        return minDepth(root: root?.right) + 1
    }
    
    if root?.right == nil {
        return minDepth(root: root?.left) + 1
    }
    
    return min(minDepth(root: root?.left), minDepth(root: root?.right)) + 1
}

// max depth of BT
func maxDepth(root: BinaryTreeNode?) -> Int {
    if root == nil {
        return 0
    }
    
    return 1 + max(maxDepth(root: root?.left), maxDepth(root: root?.right))
}

// sum of left leaves
func sumOfLeftLeaves(_ root: BinaryTreeNode?) -> Int {
    if root == nil || root?.left == nil && root?.right == nil {
        return 0
    }
    var sum = 0
    
    var queue = Queue<BinaryTreeNode>()
    queue.enqueue(root!)
    
    
    while !queue.isEmpty {
        let node = queue.dequeue()
        
        if node?.left != nil {
            queue.enqueue((node?.left)!)
        }
        if node?.right != nil {
            queue.enqueue((node?.right)!)
        }
        
        if node?.left != nil && node?.left?.right == nil && node?.left?.left == nil {
            sum += (node?.left?.val)!
        }
    }
    
    return sum
}
